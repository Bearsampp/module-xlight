/*
 * Bearsampp Module Xlight - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that replaces the legacy Ant build system.
 * All build logic has been converted to native Gradle tasks.
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=3.9.4.6    - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'xlight')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath
    buildPropertiesFile = file('build.properties').absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'xlight')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'bins')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // External build base path precedence: build.properties (build.path) -> env(BEARSAMPP_BUILD_PATH) -> default <root>/bearsampp-build
    def buildPathFromProps = (buildProps.getProperty('build.path', '') ?: '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"
    buildBasePath = buildPathFromProps ? buildPathFromProps : (buildPathFromEnv ? buildPathFromEnv : defaultBuildPath)

    // Shared external tmp tree
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}").absolutePath
    bundleTmpSrcPath = file("${buildTmpPath}/bundles_src").absolutePath
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath
    bundleTmpExtractPath = file("${buildTmpPath}/extract/${bundleName}").absolutePath

    // Final external output path for archives (e.g., bearsampp-build/bins/xlight/2025.7.31)
    moduleBuildOutputPath = file("${buildBasePath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    logger.warn("Dev path not found: ${ext.devPath}. Some tasks may not work correctly.")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// GRADLE NATIVE TASKS - Pure Gradle Implementation
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture values at configuration time to avoid deprecation warnings
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module Xlight - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Base:   ${buildBasePath}
          Output Dir:   ${moduleBuildOutputPath}
          Tmp Root:     ${buildTmpPath}
          Tmp Prep:     ${bundleTmpPrepPath}
          Tmp Build:    ${bundleTmpBuildPath}
          Tmp Src:      ${bundleTmpSrcPath}
          Downloads:    ${bundleTmpDownloadPath}
          Extract:      ${bundleTmpExtractPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                          - List all available tasks
          gradle info                           - Show this information
          gradle release                        - Interactive release build
          gradle release -PbundleVersion=3.9.4.6 - Non-interactive release
          gradle clean                          - Clean build artifacts
          gradle verify                         - Verify build environment
        """.stripIndent()
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
            println "Cleaned: ${buildDir}"
        }

        // Clean temporary directories
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            delete tmpDir
            println "Cleaned: ${tmpDir}"
        }

        // Clean Gradle-specific temp files
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
            println "Cleaned: ${gradleBundleVersion.name}"
        }

        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-xlight..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release                        - Interactive release"
            println "  gradle release -PbundleVersion=3.9.4.6 - Non-interactive release"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Helper function to find 7-Zip executable
def find7ZipExecutable() {
    // Check environment variable
    def sevenZipHome = System.getenv('7Z_HOME')
    if (sevenZipHome) {
        def exe = file("${sevenZipHome}/7z.exe")
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Check common installation paths
    def commonPaths = [
        'C:/Program Files/7-Zip/7z.exe',
        'C:/Program Files (x86)/7-Zip/7z.exe',
        'D:/Program Files/7-Zip/7z.exe',
        'D:/Program Files (x86)/7-Zip/7z.exe'
    ]

    for (path in commonPaths) {
        def exe = file(path)
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Try to find in PATH
    try {
        def process = ['where', '7z.exe'].execute()
        process.waitFor()
        if (process.exitValue() == 0) {
            def output = process.text.trim()
            if (output) {
                return output.split('\n')[0].trim()
            }
        }
    } catch (Exception e) {
        // Ignore
    }

    return null
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash} ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash} ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash} ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash} ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper: Fetch xlight.properties from modules-untouched repository
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/xlight.properties"
    
    println "Fetching xlight.properties from modules-untouched repository..."
    println "  URL: ${propsUrl}"
    
    def tempFile = file("${bundleTmpDownloadPath}/xlight-untouched.properties")
    tempFile.parentFile.mkdirs()
    
    try {
        // Download using Java URL connection
        new URL(propsUrl).withInputStream { input ->
            tempFile.withOutputStream { output ->
                output << input
            }
        }
        
        def props = new Properties()
        tempFile.withInputStream { props.load(it) }
        
        println "  ✓ Successfully loaded ${props.size()} versions from modules-untouched"
        return props
    } catch (Exception e) {
        println "  ✗ Warning: Could not fetch xlight.properties from modules-untouched: ${e.message}"
        println "  Will fall back to standard URL format if needed"
        return null
    }
}

// Helper: Download Xlight binaries from modules-untouched repository
def downloadFromModulesUntouched(String version, File destDir) {
    def untouchedProps = fetchModulesUntouchedProperties()
    def untouchedUrl = null
    
    if (untouchedProps) {
        untouchedUrl = untouchedProps.getProperty(version)
        if (untouchedUrl) {
            println "Found version ${version} in modules-untouched xlight.properties"
            println "Downloading from:"
            println "  ${untouchedUrl}"
        } else {
            throw new GradleException("Version ${version} not found in modules-untouched xlight.properties")
        }
    } else {
        throw new GradleException("Could not fetch xlight.properties from modules-untouched")
    }
    
    // Determine filename from URL
    def filename = untouchedUrl.substring(untouchedUrl.lastIndexOf('/') + 1)
    def downloadDir = file(bundleTmpDownloadPath)
    downloadDir.mkdirs()
    
    def downloadedFile = file("${downloadDir}/${filename}")
    
    // Download if not already present
    if (!downloadedFile.exists()) {
        println "  Downloading..."
        new URL(untouchedUrl).withInputStream { input ->
            downloadedFile.withOutputStream { output ->
                output << input
            }
        }
        println "  ✓ Downloaded: ${downloadedFile.name}"
    } else {
        println "  ✓ Already downloaded: ${downloadedFile.name}"
    }
    
    return downloadedFile
}

// Helper: Download and extract Xlight binaries
def downloadAndExtractXlight(String version, File destDir) {
    // Download from modules-untouched
    def downloadedFile = downloadFromModulesUntouched(version, destDir)
    
    // Extract the archive
    def extractDir = file(bundleTmpExtractPath)
    extractDir.mkdirs()
    println "  Extracting archive..."
    def extractPath = file("${extractDir}/${version}")
    if (extractPath.exists()) {
        delete extractPath
    }
    extractPath.mkdirs()
    
    // Extract using appropriate method
    extractArchive(downloadedFile, extractPath)
    
    // Find the Xlight directory (it might be nested)
    def xlightDir = findXlightDirectory(extractPath)
    if (!xlightDir) {
        throw new GradleException("Could not find Xlight directory in extracted archive")
    }
    
    println "  Extracted to: ${xlightDir}"
    return xlightDir
}

// Helper: Find Xlight directory containing xlight.exe
def findXlightDirectory(File searchDir) {
    // Case 1: Check if xlight.exe is directly in this directory
    def xlightExe = new File(searchDir, 'xlight.exe')
    if (xlightExe.exists()) {
        return searchDir
    }
    
    // Case 2: Recursively search for a directory containing xlight.exe
    File found = null
    def stack = new ArrayDeque<File>()
    stack.push(searchDir)
    
    while (!stack.isEmpty() && !found) {
        def current = stack.pop()
        def children = current.listFiles()
        if (children) {
            for (def child : children) {
                if (child.isDirectory()) {
                    def exe = new File(child, 'xlight.exe')
                    if (exe.exists()) {
                        found = child
                        break
                    }
                    stack.push(child)
                }
            }
        }
    }
    
    return found
}

// Task: Download file helper
def downloadFile(String url, File destDir) {
    if (!url) {
        throw new GradleException("Download URL is null or empty")
    }
    
    def fileName = url.tokenize('/').last()
    def destFile = new File(destDir, fileName)

    if (!destFile.exists()) {
        println "Downloading: ${url}"
        destFile.parentFile.mkdirs()

        new URL(url).withInputStream { input ->
            destFile.withOutputStream { output ->
                output << input
            }
        }
        println "Downloaded to: ${destFile}"
    } else {
        println "Already exists: ${destFile}"
    }

    return destFile
}

// Task: Extract archive helper
def extractArchive(File archive, File destDir) {
    destDir.mkdirs()

    if (archive.name.endsWith('.zip')) {
        copy {
            from zipTree(archive)
            into destDir
        }
    } else if (archive.name.endsWith('.7z')) {
        // Find 7z executable
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("7-Zip not found. Cannot extract .7z archive: ${archive.name}")
        }
        
        // Extract using ProcessBuilder
        def command = [
            sevenZipExe,
            'x',
            archive.absolutePath,
            "-o${destDir.absolutePath}",
            '-y'
        ]
        
        def process = new ProcessBuilder(command as String[])
            .redirectErrorStream(true)
            .start()
        
        def output = new StringBuilder()
        process.inputStream.eachLine { line ->
            output.append(line).append('\n')
        }
        
        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7-Zip extraction failed with exit code: ${exitCode}\nOutput: ${output}")
        }
    }

    println "Extracted to: ${destDir}"
}

// Helper methods for version discovery and selection
def findAvailableVersions = {
    def binDir = new File(projectDir, 'bin')
    def archivedDir = new File(projectDir, 'bin/archived')
    def versions = [] as List<String>

    if (binDir.exists()) {
        versions.addAll(
            (binDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    if (archivedDir.exists()) {
        versions.addAll(
            (archivedDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    return versions.unique()
}

def latestVersion = { List<String> versions ->
    if (versions.isEmpty()) return null
    // Compare numerically by dot-separated parts
    return versions.max { a, b ->
        def pa = a.split('\\.').collect { it as int }
        def pb = b.split('\\.').collect { it as int }
        def len = Math.max(pa.size(), pb.size())
        for (int i = 0; i < len; i++) {
            def ai = i < pa.size() ? pa[i] : 0
            def bi = i < pb.size() ? pb[i] : 0
            if (ai != bi) return ai <=> bi
        }
        return 0
    }
}

// Task: Resolve version (interactive by default; supports -PbundleVersion and '*')
tasks.register('resolveVersion') {
    group = 'build'
    description = 'Resolve bundleVersion (interactive by default, or use -PbundleVersion=*,<ver>)'
    
    // Capture properties at configuration time
    def versionProperty = project.findProperty('bundleVersion')
    def projectDirPath = projectDir
    def bundleNameValue = bundleName

    doLast {
        def supplied = versionProperty as String
        // Aggregate both bin/ and bin/archived/ and display with location tags
        def all = findAvailableVersions().sort { a, b ->
            def pa = a.split('\\.').collect { it as int }
            def pb = b.split('\\.').collect { it as int }
            for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }
        def inBin = new File(projectDir, 'bin').exists() ? (new File(projectDir, 'bin').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []
        def inArchived = new File(projectDir, 'bin/archived').exists() ? (new File(projectDir, 'bin/archived').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        String resolved
        if (supplied) {
            if (supplied == '*') {
                resolved = latestVersion(all)
                if (!resolved) {
                    throw new GradleException("No versions found under bin/ to resolve latest from.")
                }
                println "Resolved latest version: ${resolved}"
            } else {
                resolved = supplied
            }
        } else {
            println "=".multiply(70)
            println "Available ${bundleName} versions (index, version, location):"
            println "-".multiply(70)
            all.eachWithIndex { v, idx ->
                def indexStr = String.format('%2d', idx + 1)
                def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
                println "  ${indexStr}. ${v.padRight(12)} ${tag}"
            }
            println "-".multiply(70)
            print "\nEnter version to build (index or version string): "
            System.out.flush()
            def reader = new BufferedReader(new InputStreamReader(System.in))
            def input = reader.readLine()?.trim()
            if (!input) {
                throw new GradleException("No version specified")
            }
            if (input.isInteger()) {
                def idx = input.toInteger()
                if (idx < 1 || idx > all.size()) {
                    throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
                }
                resolved = all[idx - 1]
            } else {
                resolved = input
            }
        }

        // Validate existence in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${resolved}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${resolved}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${resolved}\n\nAvailable versions:\n${listing}")
            }
        }

        // Expose to subsequent tasks as extra property
        // Store in a shared location that can be accessed by other tasks
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        propsFile.parentFile.mkdirs()
        propsFile.text = resolved
        println "\nSelected version: ${resolved}\n"
    }
}

// Task: Main release task (interactive by default; non‑interactive when -PbundleVersion provided)
tasks.register('release') {
    group = 'build'
    description = 'Build release package (interactive by default; -PbundleVersion=* or X.Y.Z for non-interactive)'

    // Always clean before building to ensure fresh build
    dependsOn 'clean', 'resolveVersion', 'packageRelease'
}

// Task: Actual release build logic
tasks.register('releaseBuild') {
    group = 'build'
    description = 'Execute the release build process'
    dependsOn 'resolveVersion'

    // Capture version at configuration time to avoid deprecation warnings
    def versionProvider = providers.provider {
        def fromProp = project.findProperty('bundleVersion') as String
        if (fromProp) return fromProp
        // Read from file written by resolveVersion task
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        if (propsFile.exists()) {
            return propsFile.text.trim()
        }
        return null
    }

    doLast {
        def versionToBuild = versionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Resolve config folder from bin/ or bin/archived/ (contains extras.properties, etc.)
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                throw new GradleException("Bundle folder not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}")
            }
        }

        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        println "Processing bundle: ${bundleFolder}"
        println "Version: ${bundleVersion}"
        
        // Determine source paths for Xlight binaries
        def bundleSrcDest = bundlePath
        def bundleSrcFinal = bundleSrcDest
        
        // Check if xlight.exe exists in bin/ directory (it won't - only config files are there)
        def xlightExe = file("${bundleSrcFinal}/xlight.exe")
        if (!xlightExe.exists()) {
            // Xlight binaries not found in bin/ - check if already downloaded to bearsampp-build/tmp
            def tmpExtractPath = file("${bundleTmpExtractPath}/${bundleVersion}")
            def tmpXlightDir = findXlightDirectory(tmpExtractPath)
            
            if (tmpXlightDir && tmpXlightDir.exists()) {
                println "Using cached Xlight binaries from bearsampp-build/tmp"
                bundleSrcFinal = tmpXlightDir
            } else {
                // Download and extract to bearsampp-build/tmp
                println ""
                println "Xlight binaries not found"
                println "Downloading Xlight ${bundleVersion}..."
                println ""
                
                try {
                    // Download and extract to bearsampp-build/tmp
                    bundleSrcFinal = downloadAndExtractXlight(bundleVersion, file(bundleTmpExtractPath))
                } catch (Exception e) {
                    throw new GradleException("""
                        Failed to download Xlight binaries: ${e.message}
                        
                        You can manually download and extract Xlight binaries to:
                          ${bundleSrcDest}/
                        
                        Or check that version ${bundleVersion} exists in modules-untouched xlight.properties
                    """.stripIndent())
                }
            }
        }
        
        // Verify xlight.exe exists
        xlightExe = file("${bundleSrcFinal}/xlight.exe")
        if (!xlightExe.exists()) {
            throw new GradleException("xlight.exe not found at ${xlightExe}")
        }
        
        println "Source folder: ${bundleSrcFinal}"
        println ""

        // Prepare Xlight directory
        def xlightPrepPath = new File(bundleTmpPrepPath, bundleFolder)
        delete xlightPrepPath
        xlightPrepPath.mkdirs()

        println "Preparation path: ${xlightPrepPath}"

        // Copy base Xlight binaries (excluding extras.properties)
        println "Copying base Xlight files..."
        copy {
            from bundleSrcFinal
            into xlightPrepPath
            exclude 'extras.properties'
        }
        
        // Copy config files from bin/ directory (bearsampp.conf, ftpd.*, etc.)
        println "Copying configuration files..."
        copy {
            from bundleSrcDest
            into xlightPrepPath
        }

        // Process dependencies if extras.properties exists
        def extrasFile = new File(bundlePath, 'extras.properties')
        if (extrasFile.exists()) {
            println "Processing dependencies..."
            processDependencies(extrasFile, xlightPrepPath)
        }

        // Store the archive info for final message
        // Note: Using extensions.extraProperties to avoid Task.project deprecation
        extensions.extraProperties.set('preparedBundlePath', xlightPrepPath.absolutePath)
    }
}

// Helper: Process dependencies (extras.properties)
def processDependencies(File extrasFile, File xlightPrepPath) {
    def extras = new Properties()
    extrasFile.withInputStream { extras.load(it) }

    extras.each { key, url ->
        def depName = key.toString()
        println "  Processing dependency: ${depName}"

        // Download dependency
        def downloadDir = file("${bundleTmpDownloadPath}/extras/${depName}")
        def depArchive = downloadFile(url.toString(), downloadDir)

        // Extract if needed
        def depDir = downloadDir
        if (depArchive.name.endsWith('.zip') || depArchive.name.endsWith('.7z')) {
            depDir = file("${downloadDir}/extracted")
            extractArchive(depArchive, depDir)
        }

        // Copy extracted files to xlightPrepPath
        copy {
            from depDir
            into xlightPrepPath
        }
        println "    Copied ${depName} files"
    }
}

// Task: Package release as archive (ensures the version folder is included at archive root)
// - Creates: bearsampp-build/bins/xlight/<bundle.release>/bearsampp-xlight-<version>-<bundle.release>.<format>
// - The archive contains the top-level folder: <bundleName><version>/ ...
// Provider resolves version from either -PbundleVersion or value set by resolveVersion
def bundleVersionProvider = providers.provider {
    def fromProp = project.findProperty('bundleVersion') as String
    if (fromProp) return fromProp
    // Read from file written by resolveVersion task
    def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
    if (propsFile.exists()) {
        return propsFile.text.trim()
    }
    return null
}
def externalOutputDir = file("${moduleBuildOutputPath}")

// Guard task: ensure bundleVersion is resolved before any packaging runs
tasks.register('assertVersionResolved') {
    group = 'build'
    description = 'Fail fast if bundleVersion was not resolved by resolveVersion'
    dependsOn 'resolveVersion'
    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set. Run 'gradle resolveVersion' or invoke 'gradle release -PbundleVersion=<'*'|X.Y.Z>'")
        }
    }
}

// 7z packager (uses ProcessBuilder pattern from MySQL for better control)
tasks.register('packageRelease7z') {
    group = 'build'
    description = 'Package release into a .7z archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared xlight directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        externalOutputDir.mkdirs()
        def archiveName = "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.7z"
        def archiveFile = new File(externalOutputDir, archiveName)

        // Delete existing archive if present
        if (archiveFile.exists()) {
            delete archiveFile
        }

        println "Packaging (7z): ${archiveFile}"
        println "Included root folder: ${bundleFolder}/"

        // Find 7z executable
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("""
                7-Zip not found. Please install 7-Zip or set 7Z_HOME environment variable.
                
                Download from: https://www.7-zip.org/
                Or set 7Z_HOME to your 7-Zip installation directory.
            """.stripIndent())
        }

        // Create 7z archive using ProcessBuilder
        // To ensure the archive contains the version folder (e.g., xlight3.9.4.6) at the root,
        // we run 7-Zip from the parent directory and add the folder name explicitly.
        def command = [
            sevenZipExe,
            'a',
            '-t7z',
            archiveFile.absolutePath.toString(),
            bundleFolder
        ]

        def process = new ProcessBuilder(command as String[])
            .directory(prepRoot)
            .redirectErrorStream(true)
            .start()

        process.inputStream.eachLine { line ->
            if (line.trim()) println "  ${line}"
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7-Zip compression failed with exit code: ${exitCode}")
        }

        println "Archive created: ${archiveFile}"
        
        // Copy uncompressed files to build path
        def buildOutputDir = file("${bundleTmpBuildPath}/${bundleFolder}")
        println "Copying uncompressed files to: ${buildOutputDir}"
        delete buildOutputDir
        buildOutputDir.mkdirs()
        copy {
            from srcDir
            into buildOutputDir
        }
        println "Uncompressed files copied to build directory"
    }
}

// Zip packager (Gradle native Zip task) — used if bundle.format != 7z
tasks.register('packageReleaseZip', Zip) {
    group = 'build'
    description = 'Package release into a .zip archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doFirst {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared xlight directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        archiveFileName.set("bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.zip")
        destinationDirectory.set(externalOutputDir)

        // Include the version folder as the top-level entry in the archive
        from(prepRoot) {
            include "${bundleFolder}/**"
        }

        println "Packaging (zip): ${new File(externalOutputDir, archiveFileName.get()).absolutePath}"
        println "Included root folder: ${bundleFolder}/"
    }
    
    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        
        // Copy uncompressed files to build path
        def buildOutputDir = file("${bundleTmpBuildPath}/${bundleFolder}")
        println "Copying uncompressed files to: ${buildOutputDir}"
        delete buildOutputDir
        buildOutputDir.mkdirs()
        copy {
            from srcDir
            into buildOutputDir
        }
        println "Uncompressed files copied to build directory"
    }
}

// Dispatcher task that chooses packager based on bundle.format (configured without executing tasks programmatically)
def archiveFormat = (bundleFormat ?: '7z').toLowerCase()
tasks.register('packageRelease') {
    group = 'build'
    description = 'Package release into archive (7z or zip) including the version folder at root'
    // Ensure the preparation step runs before packaging
    dependsOn 'resolveVersion', 'releaseBuild', 'assertVersionResolved'
    // Select the concrete packager at configuration time based on build.properties
    dependsOn archiveFormat == '7z' ? 'packageRelease7z' : 'packageReleaseZip'
}

// Task: Generate hash files for the produced archive (.md5, .sha1, .sha256, .sha512)
tasks.register('generateHashes') {
    group = 'build'
    description = 'Generate hash sidecar files for the packaged archive'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }
        def extFormat = (bundleFormat ?: '7z').toLowerCase()
        def archive = new File(externalOutputDir, "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.${extFormat}")
        if (!archive.exists()) {
            throw new GradleException("Archive not found for hashing: ${archive}")
        }

        def calcHash = { File f, String algorithm ->
            def digest = java.security.MessageDigest.getInstance(algorithm)
            f.withInputStream { stream ->
                byte[] buf = new byte[8192]
                int r
                while ((r = stream.read(buf)) != -1) {
                    digest.update(buf, 0, r)
                }
            }
            digest.digest().collect { String.format('%02x', it) }.join('')
        }

        def writeHash = { String algo, String ext ->
            def h = calcHash(archive, algo)
            def out = new File(archive.absolutePath + ".${ext}")
            out.text = "${h} ${archive.name}\n"
            println "Created: ${out.name}"
        }

        writeHash('MD5', 'md5')
        writeHash('SHA-1', 'sha1')
        writeHash('SHA-256', 'sha256')
        writeHash('SHA-512', 'sha512')
        
        // Print final success message
        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output directory: ${file("${bundleTmpBuildPath}/${bundleName}${versionToBuild}").absolutePath}"
        println "Archive: ${archive.absolutePath}"
        println "=".multiply(70)
    }
}

// Ensure hashes are generated after packaging during release, and cleanup temp files
tasks.named('release') {
    finalizedBy 'generateHashes', 'cleanupTempFiles'
}

// Task: Cleanup temporary Gradle-specific files after build
tasks.register('cleanupTempFiles') {
    group = 'build'
    description = 'Cleanup temporary Gradle-specific files after build'
    
    doLast {
        // Clean Gradle-specific temp files
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
            println "Cleaned up: ${gradleBundleVersion.name}"
        }
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable Xlight Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")

        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def inBin = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []

        def inArchived = archivedDir.exists() ? (archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        def allVersions = (inBin + inArchived).toSet().toList().sort { a, b ->
            def pa = a.split('\\.').collect { it as int }
            def pb = b.split('\\.').collect { it as int }
            for (int i = 0; i < Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }

        println "\nAvailable ${bundleName} versions (index, version, location):"
        println "-".multiply(60)
        allVersions.eachWithIndex { v, idx ->
            def tag
            def inBinFlag = inBin.contains(v)
            def inArchivedFlag = inArchived.contains(v)
            if (inBinFlag && inArchivedFlag) {
                tag = "[bin + bin/archived]"
            } else if (inBinFlag) {
                tag = "[bin]"
            } else if (inArchivedFlag) {
                tag = "[bin/archived]"
            } else {
                tag = "[unknown]"
            }
            def indexStr = String.format('%2d', idx + 1)
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(60)
        println "Total versions: ${allVersions.size()}"
        if (!allVersions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${allVersions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: List dependencies
tasks.register('listDependencies') {
    group = 'help'
    description = 'List dependencies configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for dependency configurations..."
        println "=".multiply(80)

        def foundDeps = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def extrasFile = new File(versionDir, 'extras.properties')
                if (extrasFile.exists()) {
                    foundDeps = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nXlight ${version}:"
                    println "-".multiply(80)

                    def extras = new Properties()
                    extrasFile.withInputStream { extras.load(it) }

                    extras.sort { it.key }.each { dep, url ->
                        println "  ${dep.toString().padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundDeps) {
            println "No dependency configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: Show Xlight-specific build information
tasks.register('xlightInfo') {
    group = 'help'
    description = 'Display Xlight-specific build information'

    doLast {
        println """
        ================================================================
                  Xlight Module Build - Specific Information
        ================================================================

        This module includes special build processes for:

        1. Xlight FTP Server Binaries
           - Downloads from modules-untouched repository
           - Extracts and prepares Xlight FTP server files

        2. Dependencies (extras.properties)
           - Downloads required extras (help, remote admin, language packs)
           - Integrates dependencies into the build

        Configuration Files:
          - extras.properties    : Additional components to include

        Useful Commands:
          gradle listDependencies   - Show dependencies
          gradle xlightInfo         - Show this information
        """.stripIndent()
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module Xlight - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
